[
  {
    "name": "qc",
    "function": " ",
    "casenya": "case 'qc':{\n\nif (!args[0] && !m.quoted) {\nreturn m.reply(`Where is the text?`)\n}\nlet userPfp\nif (m.quoted) {\ntry {\nuserPfp = await riza.profilePictureUrl(m.quoted.sender, \"image\")\n} catch (e) {\nuserPfp = imageUrls\n}\n} else {\ntry {\nuserPfp = await riza.profilePictureUrl(m.sender, \"image\")\n} catch (e) {\nuserPfp = imageUrls\n}\n}\nconst waUserName = pushname\nconst quoteText = m.quoted ? m.quoted.body : args.join(\" \")\nconst quoteJson = {\n      type: \"quote\",\n      format: \"png\",\n      backgroundColor: \"#FFFFFF\",\n      width: 700,\n      height: 580,\n      scale: 2,\n      messages: [\n        {\n          entities: [],\n          avatar: true,\n          from: {\n            id: 1,\n            name: waUserName,\n            photo: {\n              url: userPfp,\n            },\n          },\n          text: quoteText,\n          replyMessage: {},\n        },\n      ],\n    }\n    try {\n      const quoteResponse = await axios.post(\"https://bot.lyo.su/quote/generate\", quoteJson, {\n        headers: { \"Content-Type\": \"application/json\" },\n      })\n      const buffer = Buffer.from(quoteResponse.data.result.image, \"base64\")\n      riza.sendImageAsSticker(m.chat, buffer, m, {\n        packname: 'Eriza',\n        author: 'Gamtenk',\n      })\n    } catch (error) {\n      console.error(error)\n      m.reply('Error')\n    }\n    }\nbreak;",
    "upFile": []
  },
  {
    "name": "tourl",
    "function": " ",
    "casenya": "case \"tourl\": {\n    if (!/image/.test(mime)) return m.reply(\"‚ö†Ô∏è Silakan kirim atau reply foto!\");\n    const qmsg = (quoted.msg || quoted)\n    let media = await riza.downloadAndSaveMediaMessage(qmsg);\n    try {\n        // Import library\n        const { ImageUploadService } = require('node-upload-images');\n        const service = new ImageUploadService('pixhost.to');\n        // Upload gambar\n        let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'imgtmp.png');\n        let url = directLink.toString();\n        // Pesan berhasil\n        let teksnya = `‚úÖ *Sukses Convert Image to URL!*`;\n        let msgii = generateWAMessageFromContent(m.chat, { viewOnceMessage: { message: { \n            \"messageContextInfo\": { \n                \"deviceListMetadata\": {}, \n                \"deviceListMetadataVersion\": 2\n            }, \n            interactiveMessage: proto.Message.InteractiveMessage.create({\n                contextInfo: { mentionedJid: [m.sender] }, \n                body: proto.Message.InteractiveMessage.Body.create({ text: teksnya }), \n                nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n                    buttons: [\n                        {\n                            \"name\": \"cta_url\",\n                            \"buttonParamsJson\": JSON.stringify({\n                                \"display_text\": \"üîó Preview Media\",\n                                \"url\": url,\n                                \"merchant_url\": url\n                            })\n                        },\n                        {\n                            \"name\": \"cta_copy\",\n                            \"buttonParamsJson\": JSON.stringify({\n                                \"display_text\": \"üìã Copy URL Gambar\",\n                                \"copy_code\": url\n                            })\n                        }\n                    ]\n                })\n            })\n        }}}, {userJid: m.sender, quoted: m}); \n        await riza.relayMessage(msgii.key.remoteJid, msgii.message, { \n            messageId: msgii.key.id \n        });\n    } catch (error) {\n        console.error(\"Error pada tourl:\", error);\n        m.reply(\"‚ùå Gagal mengunggah gambar. Coba lagi nanti!\");\n    }\n    await fs.unlinkSync(media);\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "ssweb",
    "function": " ",
    "casenya": "case \"ssweb\": {\n    try {\n        // Ambil URL dari input pengguna\n        let url = text.trim();\n        if (!url) return m.reply(\"‚ö†Ô∏è Harap masukkan URL website yang ingin di-screenshot!\\n*Contoh:* .ssweb https://example.com\");\n        // Pastikan URL memiliki format yang benar\n        if (!/^https?:\\/\\//.test(url)) url = \"https://\" + url;\n        // URL API untuk mengambil screenshot\n        let screenshotUrl = `https://api.siputzx.my.id/api/tools/ssweb?url=${encodeURIComponent(url)}&theme=light&device=desktop`;\n        // Kirim gambar ke pengguna\n        await riza.sendMessage(m.chat, { \n            image: { url: screenshotUrl },\n            caption: `üì∏ *Screenshot Website*\\nüåê *URL:* ${url}\\nüñ•Ô∏è *Mode:* Desktop\\n‚òÄÔ∏è *Tema:* Light`\n        }, { quoted: m });\n    } catch (error) {\n        console.error(\"‚ùå Error saat mengambil screenshot:\", error);\n        m.reply(\"‚ö†Ô∏è Gagal mengambil screenshot. Coba lagi nanti.\");\n    }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "emojimix",
    "function": " ",
    "casenya": "case 'emojimix': {\n\nlet emojisatu = text.split('+')[0]\nlet emojidua = text.split('+')[1]\nif (!emojisatu && !emojidua) return m.reply(`*Unvalid Format!*\nExample : ${prefix+command} üòâ+üò≠`)\naxios.get(`https://apirest.sazxofficial.web.id/api/imagecreator/emojimix?emoji1=${emojisatu}&emoji2=${emojidua}`)\n.then(({data}) => {\nriza.sendImageAsSticker(from, data.result, m, { packname: 'Eriza', author: 'Official' })\n})\n}\nbreak",
    "upFile": []
  },
  {
    "name": "sticker",
    "function": " ",
    "casenya": "case 'sticker':{\nif (!quoted) return\nif (/image/.test(mime)) {\nlet media = await quoted.download()\nlet encmedia = await riza.sendImageAsSticker(m?.chat, media, m, {\npackname: 'Eriza',\nauthor: 'Official'\n})\nawait fs.unlinkSync(encmedia)\n} else if (/video/.test(mime)) {\nif ((quoted.msg || quoted).seconds > 11) return m?.reply('Maksimal 10 detik!')\nlet media = await quoted.download()\nlet encmedia = await riza.sendVideoAsSticker(m?.chat, media, m, {\npackname: 'Eriza',\nauthor: 'Official'\n})\nawait fs.unlinkSync(encmedia)\n} else {\nreturn m?.reply(`Kirim Gambar/Video Dengan Caption ${prefix + command}\\nDurasi Video 1-9 Detik`)\n}\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "removebg",
    "function": " ",
    "casenya": "case 'removebg': {\n\n if (!/image/.test(mime)) return m.reply(\"‚ö†Ô∏è Silakan kirim atau reply foto!\");\n const rqmsg = (quoted.msg || quoted)\n let media = await riza.donwloadAndSaveMediaMessage(rqmsg);\n try {\n // Mengonversi gambar ke URL menggunakan kode yang sudah ada\n const { ImageUploadService } = require('node-upload-images');\n const service = new ImageUploadService('pixhost.to');\n // Mengunggah gambar ke Pixhost\n let { directLink } = await service.uploadFromBinary(fs.readFileSync(media), 'imgtmp.png');\n let urlGambar = directLink.toString();\n // Menggunakan API untuk menghapus background\n let removeBgUrl = `https://api.siputzx.my.id/api/iloveimg/removebg?image=${urlGambar}&scale=2`;\n // Mengirimkan gambar hasil background yang dihapus\n await riza.sendMessage(m.chat, {\n image: { url: removeBgUrl },\n caption: \"‚úÖ Background berhasil dihapus!\",\n }, { quoted: m });\n } catch (error) {\n console.error(\"Error pada removebg:\", error);\n m.reply(\"‚ùå Gagal menghapus background. Coba lagi nanti!\");\n }\n await fs.unlinkSync(media); // Menghapus file sementara\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "mediafire",
    "function": " ",
    "casenya": "case 'mediafire': {\n if (!text) return m.reply('Gunakan format: .mediafire <link_mediafire>');\n if (!text.includes('mediafire.com')) return m.reply('Link yang diberikan bukan dari MediaFire.');\n try {\n let res = await fetch(`https://vapis.my.id/api/mfdl?url=${encodeURIComponent(text)}`);\n let response = await res.json();\n if (!response?.status || !response?.data?.result) {\n return m.reply(`Gagal mengambil data dari MediaFire.\\n\\n*Format Error API:*\\n${JSON.stringify(response, null, 2)}`);\n }\n let { filename, size, download, mimetype } = response.data.result;\n let caption = `*MediaFire Downloader*\\n\\n> FileName: \\n\\`${filename}\\`\\n> Ukuran: ${size}`;\n let fileRes = await fetch(download);\n if (!fileRes.ok) {\n return m.reply(`Gagal mengunduh file dari MediaFire.\\n\\n*Error Status:* ${fileRes.status} ${fileRes.statusText}`);\n }\n let fileData = await fileRes.arrayBuffer(); // Menggunakan arrayBuffer() agar bisa dikirim sebagai dokumen\n await riza.sendMessage(m.chat, {\n document: Buffer.from(fileData),\n mimetype: mimetype || 'application/octet-stream',\n fileName: filename,\n caption: caption\n }, { quoted: m });\n } catch (e) {\n console.error(e);\n m.reply(`Terjadi kesalahan saat mengunduh file dari MediaFire.\\n\\n*Error Message:*\\n${e.message}`);\n }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "remini",
    "function": "async function Upscale(imageBuffer) {\n    try {\n        const response = await fetch(\"https://lexica.qewertyy.dev/upscale\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                image_data: imageBuffer.toString(\"base64\"), \n                format: \"binary\"\n            })\n        })\n        return Buffer.from(await response.arrayBuffer())\n    } catch {\n        return null\n    }\n}",
    "casenya": "case 'remini' : {\n    riza.enhancer = riza.enhancer || {}\n\n    if (m.sender in riza.enhancer)\n        throw \"‚ùóMasih ada proses yang belum selesai. Silakan tunggu.\"\n\n    let q = m.quoted ? m.quoted : m\n    let mime = (q.msg || q).mimetype || q.mediaType || \"\"\n    if (!mime) throw \"‚ùóKirim/Reply foto.\";\n    if (!/image\\/(jpe?g|png)/.test(mime)) throw `‚ùó Mimetype ${mime} tidak didukung.`\n\n    riza.enhancer[m.sender] = true\n    await riza.sendMessage(m.chat, { react: { text: \"üåÄ\", key: m.key } })\n\n    let img = await q.download?.()\n    let enhancedImg = await Upscale(img)\n\n    if (enhancedImg) {\n        await riza.sendMessage(m.chat, { react: { text: \"‚úÖ\", key: m.key } })\n        riza.sendMessage(m.chat,{image: enhancedImg, caption: \"*Success Enhanced ‚ùáÔ∏è*\"},{quoted:m})\n    } else {\n        await riza.sendMessage(m.chat, { react: { text: \"‚ùå\", key: m.key } })\n        m.reply(\"*Result:* Failed \");\n    }\n\n    delete riza.enhancer[m.sender]\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "ttmp4",
    "function": " ",
    "casenya": "case 'ttmp4': {\n    if (typeof text !== \"string\" || !text.trim()) {\n        return m.reply(`Example: ${prefix + command} https://vt.tiktok.com/ZS6qRB5Dm/`);\n    }\n    await riza.sendMessage(m.chat, { react: { text: \"üöÄ\", key: m.key, }}) \n    await fetch(`https://api.diioffc.web.id/api/download/tiktok?url=${encodeURIComponent(text)}`)\n        .then(res => res.json())\n        .then(response => {\n            if (!response.status) {\n                return m.reply('Gagal mendapatkan data video TikTok.');\n            }\n            let { play, title } = response.result;\n            riza.sendMessage(m.chat, {\n                video: { url: play },\n                mimetype: 'video/mp4',\n                caption: `üé• *Judul:* ${title}`\n            }, { quoted: m });\n        })\n        .catch(err => {\n            console.error(err);\n            m.reply('Terjadi Kesalahan dalam mendapatkan video.');\n        });\n    await riza.sendMessage(m.chat, { react: { text: \"‚òëÔ∏è\", key: m.key, }})\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "ttmp3",
    "function": " ",
    "casenya": "case 'ttmp3': {\n    if (typeof text !== \"string\" || !text.trim()) {\n        return m.reply(`Example: ${prefix + command} https://vt.tiktok.com/ZS6qRB5Dm/`);\n    }\n    await riza.sendMessage(m.chat, { react: { text: \"üöÄ\", key: m.key, }}) \n    await fetch(`https://api.diioffc.web.id/api/download/tiktok?url=${encodeURIComponent(text)}`)\n        .then(res => res.json())\n        .then(response => {\n            if (!response.status) {\n                return m.reply('Gagal mendapatkan data audio TikTok.');\n            }\n            let { music_info } = response.result;\n            riza.sendMessage(m.chat, {\n                audio: { url: music_info.play },\n                mimetype: \"audio/mpeg\",\n                contextInfo: {\n                    externalAdReply: {\n                        title: music_info.title,\n                        body: \"Audio dari TikTok\",\n                        thumbnailUrl: music_info.cover,\n                        mediaType: 1\n                    }\n                }\n            }, { quoted: m });\n        })\n        .catch(err => {\n            console.error(err);\n            m.reply('Terjadi Kesalahan dalam mendapatkan audio.');\n        });\n    await riza.sendMessage(m.chat, { react: { text: \"‚òëÔ∏è\", key: m.key, }})\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "play",
    "function": " ",
    "casenya": "case 'play': {\n    if (!text) return m.reply('‚ùó Harap berikan kata kunci pencarian.\\nContoh: .play mbappe');\n    let query = encodeURIComponent(text.trim());\n    m.reply('üîé Sedang mencari media, harap tunggu...');\n    try {\n        const response = await fetch(`https://vapis.my.id/api/yts?q=${query}`);\n        const result = await response.json();\n        if (result.status && result.data.length > 0) {\n            let video = result.data[Math.floor(Math.random() * result.data.length)]; // Pilih 1 data secara acak\n            let caption = `üîç *YouTube Play*\\n\\n` +\n                `üìå *Judul:* ${video.title}\\n` +\n                `‚è≥ *Durasi:* ${video.timestamp}\\n` +\n                `üë§ *Channel:* ${video.author.name}\\n` +\n                `üìÜ *Upload:* ${video.ago}\\n` +\n                `üëÄ *Views:* ${video.views.toLocaleString()}\\n\\n` +\n                `üîó *URL:* ${video.url}`;\n            await riza.sendMessage(m.chat, { \n                image: { url: video.thumbnail }, \n                caption: caption,\n                footer: \"Pilih Opsi\",\n                buttons: [\n                    {\n                        buttonId: `.ytmp3 ${video.url}`,\n                        buttonText: { displayText: 'üéµ Audio | Ytmp3' },\n                        type: 1\n                    },\n                    {\n                        buttonId: `.ytmp4 ${video.url}`,\n                        buttonText: { displayText: 'üé• Video | Ytmp4' },\n                        type: 1\n                    }\n                ],\n                headerType: 1,\n                viewOnce: true\n            }, { quoted: m });\n        } else {\n            m.reply('‚ùó Tidak ada hasil ditemukan untuk pencarian tersebut.');\n        }\n    } catch (error) {\n        console.error(error);\n        m.reply('‚ùó Terjadi kesalahan saat mencari video. Silakan coba lagi nanti.');\n    }\n    }\nbreak;",
    "upFile": []
  },
  {
    "name": "cekidch",
    "function": " ",
    "casenya": "case 'cekidch': {\n if (!text) return m.reply(\"sertakan link saluran\")\n if (!text.includes(\"https://whatsapp.com/channel/\")) return m.reply(\"Link tautan tidak valid\")\n \n let result = text.split('https://whatsapp.com/channel/')[1]\n let res = await riza.newsletterMetadata(\"invite\", result)\n \n let teks = `- *ID : ${res.id}*\n- *Nama :* ${res.name}\n- *Total Pengikut :* ${res.subscribers}\n- *Status :* ${res.state}\n- *Verified :* ${res.verification == \"VERIFIED\" ? \"Terverifikasi\" : \"Tidak\"}`\n let msg = generateWAMessageFromContent(m.chat, {\n viewOnceMessage: {\n message: { \n \"messageContextInfo\": { \n \"deviceListMetadata\": {}, \n \"deviceListMetadataVersion\": 2 \n },\n interactiveMessage: {\n body: {\n text: teks \n }, \n footer: {\n text: `¬© ${global.ownername}`\n },\n nativeFlowMessage: {\n buttons: [\n {\n \"name\": \"cta_copy\",\n \"buttonParamsJson\": `{\"display_text\": \"copy ID\",\"copy_code\": \"${res.id}\"}`\n }\n ]\n }\n }\n }\n }\n }, { quoted: qtext });\n await riza.relayMessage(msg.key.remoteJid, msg.message, { messageId: msg.key.id });\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "reactch",
    "function": " ",
    "casenya": "case \"reactch\": {\nif (!isCreator) return m.reply('Khusus Owner')\nif (!text) return m.reply(\".reactch linkpesan üòÇ\")\nif (!args[0] || !args[1]) return m.reply(\"Wrong Format\")\nif (!args[0].includes(\"https://whatsapp.com/channel/\")) return m.reply(\"Link tautan tidak valid\")\nlet result = args[0].split('/')[4]\nlet serverId = args[0].split('/')[5]\nlet res = await riza.newsletterMetadata(\"invite\", result)\nawait riza.newsletterReactMessage(res.id, serverId, args[1])\nm.reply(`Berhasil mengirim reaction ${args[1]} ke dalam channel ${res.name}`)\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "pinterest",
    "function": " ",
    "casenya": "case 'pinterest': case 'pin': {\n    if (!text) return m.reply('Sertakan Kata Kunci!');\n    m.reply('Mencari Gambar..!');\n    try {\n        let res = await fetch(`https://api.siputzx.my.id/api/s/pinterest?query=${text}`);\n        let response = await res.json();\n        if (!response.status || !response.data || response.data.length === 0) {\n            return m.reply('Tidak ada hasil ditemukan!');\n        }\n        let result = response.data[Math.floor(Math.random() * response.data.length)];\n        riza.sendMessage(m.chat, {\n            image: { url: result.images_url },\n            caption: `Judul: ${result.grid_title}\\nLink: ${result.pin}`,\n            quoted: m \n        });\n    } catch (err) {\n        m.reply('Terjadi Kesalahan');\n    }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "jpm",
    "function": "const isleep = async (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}",
    "casenya": "case \"jpm\": {\nif (!isCreator) return m.reply('Khusus Owner!')\nif (!q) return m.reply(\"teksnya\")\nlet allgrup = await riza.groupFetchAllParticipating()\nlet res = await Object.keys(allgrup)\nlet count = 0\nconst jid = m.chat\nconst teks = text\nawait m.reply(`Memproses *jpm* teks Ke ${res.length} grup`)\nfor (let i of res) {\n\ntry {\nawait riza.sendMessage(i, {text: `${teks}`}, {quoted: qloc})\ncount += 1\n} catch {}\nawait isleep(16000)\n}\nawait riza.sendMessage(jid, {text: `*Jpm Telah Selesai ‚úÖ*\\nTotal grup yang berhasil dikirim pesan : ${count}`}, {quoted: m})\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "jpmtag",
    "function": " ",
    "casenya": "case 'jpmtag': {\n try {\n if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n let args = text.split('|');\n if (args.length < 2) return m.reply('Format yang benar: .jpmtag <pesan>|<jeda>');\n let pesan = args[0].trim();\n let delay = parseInt(args[1].trim());\n if (!pesan) return m.reply('Masukkan pesan yang ingin dikirim ke semua grup.');\n if (isNaN(delay) || delay <= 0) return m.reply('Jeda harus berupa angka positif dalam milisecond, misalnya 1000 (1 detik).');\n // Ambil daftar semua grup yang bot ikuti\n let groups = await riza.groupFetchAllParticipating();\n let groupList = Object.keys(groups);\n // Cek apakah bot tergabung dalam grup\n if (groupList.length === 0) return m.reply('‚ö†Ô∏è Bot tidak tergabung dalam grup mana pun!');\n m.reply(`üì¢ Memulai JPm Tag ke ${groupList.length} grup dengan delay ${delay / 1000} detik per grup...`);\n let total = 0;\n for (let group of groupList) {\n let groupMetadata = groups[group];\n let members = groupMetadata.participants.map(p => p.id);\n let teks = `${pesan}`;\n // Kirim pesan dengan mention semua anggota grup\n await riza.sendMessage(group, {\n text: teks,\n mentions: members,\n \n },{quoted: qloc2});\n total += 1;\n // Menunggu sesuai jeda antar grup\n await new Promise(resolve => setTimeout(resolve, delay));\n }\n m.reply(`‚úÖ Berhasil mengirim pesan ke ${total} grup.`);\n } catch (error) {\n console.error('Error saat jpmtag:', error);\n m.reply('‚ùå Gagal mengirim pesan ke semua grup.');\n }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "pushkontak",
    "function": " ",
    "casenya": "case 'pushkontak': {\n    try {\n        if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n        let [pesan, groupId, jeda] = text.split('|');\n        if (!pesan || !groupId || !jeda) return m.reply('Format salah! Gunakan: *.pushkontak teks|idgrup|jeda*\\n\\nContoh: *.pushkontak Halo|120xxxxx@g.us|6000*');\n        let groupMetadata = await riza.groupMetadata(groupId);\n        if (!groupMetadata) return m.reply('Grup tidak ditemukan atau bot bukan admin di grup tersebut.');\n        let members = groupMetadata.participants.map(p => p.id);\n        if (members.length === 0) return m.reply('Tidak ada anggota di grup ini.');\n        let delayTime = parseInt(jeda); // Konversi ke angka\n        m.reply(`üì¢ Mulai mengirim pesan ke ${members.length} anggota di grup *${groupMetadata.subject}* dengan delay ${delayTime}ms per kontak.`);\n        for (let i = 0; i < members.length; i++) {\n            await riza.sendMessage(members[i], { text: pesan },{quoted:qloc});\n            console.log(`üì© Pesan terkirim ke ${members[i]} - Menunggu ${delayTime}ms sebelum kontak berikutnya.`);\n            await new Promise(resolve => setTimeout(resolve, delayTime)); // **Menunggu sesuai jeda**\n        }\n        m.reply(`‚úÖ Berhasil mengirim pesan ke semua anggota di grup *${groupMetadata.subject}*.`);\n    } catch (error) {\n        console.error('Error saat push kontak:', error);\n        m.reply('‚ùå Gagal mengirim pesan ke semua kontak.');\n    }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "kalender",
    "function": " ",
    "casenya": "case 'kalender': {\n  const currentDate = new Date();\n  // Waktu untuk zona Indonesia (WIB, WITA, WIT)\n  const wibTime = new Intl.DateTimeFormat('id-ID', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    timeZone: 'Asia/Jakarta'\n  }).format(currentDate);\n  \n  const witaTime = new Intl.DateTimeFormat('id-ID', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    timeZone: 'Asia/Makassar'\n  }).format(currentDate);\n  \n  const witTime = new Intl.DateTimeFormat('id-ID', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    timeZone: 'Asia/Jayapura'\n  }).format(currentDate);\n  // Waktu untuk server global (UTC)\n  const serverTime = new Intl.DateTimeFormat('en-GB', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    timeZone: 'UTC'\n  }).format(currentDate);\n  const message = `\nüìÖ *Kalender*:\nüåç *WIB (Jakarta)*: ${wibTime}\nüåç *WITA (Makassar)*: ${witaTime}\nüåç *WIT (Jayapura)*: ${witTime}\nüåç *Server Global (UTC)*: ${serverTime}\n  `;\n  \n  m.reply(message);\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "bratvid",
    "function": " ",
    "casenya": "case 'bratvid': {\n    if (!text) return m.reply(`Contoh: ${prefix + command} hai`);\n    if (text.length > 100) return m.reply(`Karakter terbatas, max 100!`);\n    const path = require('path');\n    const { execSync } = require('child_process');\n    const words = text.split(' ');\n    const tempDir = path.join(process.cwd(), 'session');\n    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });\n    const framePaths = [];\n    try {\n        for (let i = 0; i < words.length; i++) {\n            const currentText = words.slice(0, i + 1).join(' ');\n            const res = await axios.get(\n                `https://brat.caliphdev.com/api/brat?text=${encodeURIComponent(currentText)}`,\n                { responseType: 'arraybuffer' }\n            ).catch((e) => e.response);\n            if (!res || !res.data) return m.reply('Gagal mengambil frame dari API');\n            const framePath = path.join(tempDir, `frame${i}.mp4`);\n            fs.writeFileSync(framePath, res.data);\n            framePaths.push(framePath);\n        }\n        if (framePaths.length === 0) return m.reply('Tidak ada frame yang dihasilkan.');\n        const fileListPath = path.join(tempDir, 'filelist.txt');\n        let fileListContent = framePaths.map(frame => `file '${frame}'\\nduration 0.7`).join('\\n');\n        fileListContent += `\\nfile '${framePaths[framePaths.length - 1]}'\\nduration 2`;\n        fs.writeFileSync(fileListPath, fileListContent);\n        const outputVideoPath = path.join(tempDir, 'output.mp4');\n        const outputStickerPath = path.join(tempDir, 'output.webp');\n        execSync(\n            `ffmpeg -y -f concat -safe 0 -i ${fileListPath} -vf 'fps=30,format=yuv420p' -c:v libx264 -preset ultrafast ${outputVideoPath}`,\n            { stdio: 'ignore' }\n        );\n        if (!fs.existsSync(outputVideoPath)) return m.reply('Terjadi kesalahan dalam pembuatan video.');\n        execSync(\n            `ffmpeg -y -i ${outputVideoPath} -vf 'scale=512:512:flags=lanczos' -c:v libwebp -lossless 1 -preset default -loop 0 -an ${outputStickerPath}`,\n            { stdio: 'ignore' }\n        );\n        if (!fs.existsSync(outputStickerPath)) return m.reply('Terjadi kesalahan dalam pembuatan sticker.');\n        await riza.sendMessage(m.chat, { sticker: fs.readFileSync(outputStickerPath) }, { quoted: m });\n        framePaths.forEach(frame => fs.existsSync(frame) && fs.unlinkSync(frame));\n        if (fs.existsSync(fileListPath)) fs.unlinkSync(fileListPath);\n        if (fs.existsSync(outputVideoPath)) fs.unlinkSync(outputVideoPath);\n        if (fs.existsSync(outputStickerPath)) fs.unlinkSync(outputStickerPath);\n    } catch (e) {\n        console.error(e);\n        m.reply('Terjadi kesalahan dalam proses.');\n    }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "encrypt",
    "function": "const jsobfus = require('javascript-obfuscator')\nasync function obfus(query) {\nreturn new Promise((resolve, reject) => {\ntry {\nconst obfuscationResult = jsobfus.obfuscate(query,\n{\ncompact: false,\ncontrolFlowFlattening: true,\ncontrolFlowFlatteningThreshold: 1,\nnumbersToExpressions: true,\nsimplify: true, \nstringArrayShuffle: true,\nsplitStrings: true,\nstringArrayThreshold: 1\n}\n);\nconst result = {\nstatus: 200,\nauthor: `RizaEnc`,\nresult: obfuscationResult.getObfuscatedCode()\n}\nresolve(result)\n} catch (e) {\nreject(e)\n}\n})\n}",
    "casenya": "case 'encrypt': {\n \n if (!text) return m.reply(`Contoh: ${prefix + command} const eriza = require('eriza-api')`)\n const crypto = require('crypto')\n const fs = require('fs').promises\n const path = require('path')\n try {\n let meg = await obfus(q) // Menggunakan fungsi obfuscator\n let encryptedCode = meg.result\n let namafile = `Encrypted_${crypto.randomBytes(6).toString('hex')}.js`\n let filePath = path.join(__dirname, namafile)\n // Simpan kode yang telah dienkripsi ke dalam file\n await fs.writeFile(filePath, encryptedCode)\n // Kirim file JS hasil enkripsi\n await riza.sendMessage(m.chat, {\n document: await fs.readFile(filePath),\n fileName: namafile,\n mimetype: 'application/javascript'\n }, { quoted: m })\n // Hapus file setelah dikirim\n await fs.unlink(filePath)\n } catch (err) {\n console.error(err)\n await m.reply('Terjadi kesalahan saat mengenkripsi kode.')\n }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "sendngl",
    "function": "",
    "casenya": "case \"sendngl\": {\n try {\n // Cek apakah pengguna sudah memasukkan format yang benar\n if (!text.includes(\"|\")) return m.reply(\"‚ö†Ô∏è Format salah! Gunakan format:\\n\\n.sendngl <link>|<pesan>\\n\\n*Contoh:*\\n.sendngl https://ngl.link/xxxx|Halo, ini pesan anonim!\");\n // Pisahkan input menjadi link dan pesan\n let [link, pesan] = text.split(\"|\").map(v => v.trim());\n // Pastikan link adalah NGL yang valid\n if (!/^https:\\/\\/ngl\\.link\\//.test(link)) return m.reply(\"‚ö†Ô∏è Link NGL tidak valid! Pastikan menggunakan link dari *ngl.link*\");\n // URL API untuk mengirim pesan ke NGL\n let apiURL = `https://api.siputzx.my.id/api/tools/ngl?link=${encodeURIComponent(link)}&text=${encodeURIComponent(pesan)}`;\n // Fetch API tanpa perlu mengambil respons\n await fetch(apiURL);\n // Beri respons sukses kepada pengguna\n m.reply(`‚úÖ *Pesan berhasil dikirim!*\\n\\nüì© *Ke:* ${link}\\nüí¨ *Pesan:* ${pesan}`);\n } catch (error) {\n console.error(\"‚ùå Error saat mengirim pesan NGL:\", error);\n m.reply(\"‚ö†Ô∏è Gagal mengirim pesan NGL. Coba lagi nanti.\");\n }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "tiktokplay",
    "function": "",
    "casenya": "case 'tiktokplay': {\n\t\n if (typeof text !== \"string\" || !text.trim()) {\n return m.reply(`Example: ${prefix + command} Mobile Legends`);\n }\n m.reply('_*Sedang mencari video...*_');\n await fetch(`https://api.diioffc.web.id/api/search/tiktok?query=${encodeURIComponent(text)}`)\n .then(res => res.json())\n .then(response => {\n if (!response.status || response.result.length === 0) {\n return m.reply('Tidak ditemukan hasil untuk pencarian ini.');\n }\n let vid = response.result[Math.floor(Math.random() * response.result.length)]; // Pilih video secara acak\n let caption = `\nüé¨ *${vid.title}*\nüë§ *Creator*: ${vid.author.name} (@${vid.author.username})\nüé• *Durasi*: ${vid.duration} detik\nüëç *Like*: ${vid.stats.like} | üí¨ *Komentar*: ${vid.stats.comment}\nüîÑ *Share*: ${vid.stats.share} | ‚¨áÔ∏è *Download*: ${vid.stats.download}`;\n riza.sendMessage(m.chat, {\n video: { url: vid.media.no_watermark },\n caption,\n footer: \"Pilih format download\",\n buttons: [\n \n {\n buttonId: `.tiktokplay ${text}`,\n buttonText: { displayText: '‚è≠Ô∏è Next Video' },\n type: 1\n }\n ],\n headerType: 1,\n viewOnce: true\n }, { quoted: m });\n })\n .catch(err => {\n console.error(err);\n m.reply('Terjadi kesalahan dalam pencarian video.');\n });\n}\nbreak",
    "upFile": []
  },
  {
    "name": "txt2qr",
    "function": "",
    "casenya": "case 'txt2qr':{\n\nif (!text) return m.reply(\"text nya mana?\")\nlet urlQR = `https://api.siputzx.my.id/api/tools/text2qr?text=${encodeURIComponent(text)}`\nriza.sendMessage(m.chat, {image: {url: urlQR}, caption: 'üó≥Ô∏è Success Convert To QR'}, {quoted: qlive});\n}\nbreak",
    "upFile": []
  },
  {
    "name": "asupan",
    "function": "",
    "casenya": "case 'asupan':{\n\nif (!isPc) return m.reply(\"üí≠ *Khusus* `Private Chat`\")\nlet urlAsupan = 'https://api.agatz.xyz/api/asupan'\nlet res = await fetch(urlAsupan)\nlet response = await res.json()\nriza.sendMessage(m.chat, {video: {url: response.data}, caption: '‚ú® *Asupan Hari Ini*'},{quoted: qdoc})\n}\nbreak",
    "upFile": []
  },
  {
    "name": "hidetag",
    "function": "",
    "casenya": "case \"hidetag\": case \"h\": {\nif (!isGroup) return m.reply(`Khusus Grup`)\nif (!isCreator && !isAdmins) return m.reply(`Khusus Admin`)\nif (!m.quoted && !text) return m.reply(\"mohon sertakan pesan/reply pesan\")\nvar teks = m.quoted ? m.quoted.text : text\nvar member = await groupMetadata.participants.map(e => e.id)\nriza.sendMessage(m.chat, {text: teks, mentions: [...member]}, {quoted: qtext})\n}\nbreak",
    "upFile": []
  },
  {
    "name": "infogempa",
    "function": "",
    "casenya": "case \"infogempa\": {\n try {\n let response = await fetch(\"https://data.bmkg.go.id/DataMKG/TEWS/autogempa.json\");\n if (!response.ok) throw new Error(\"Gagal mengambil data gempa.\");\n let data = await response.json();\n let gempa = data.Infogempa.gempa;\n let pesan = `üåç *Informasi Gempa Terkini* üåç\\n\\n` +\n `üìÖ *Tanggal:* ${gempa.Tanggal}\\n` +\n `üïí *Jam:* ${gempa.Jam}\\n` +\n `üìç *Lokasi:* ${gempa.Wilayah}\\n` +\n `üìè *Magnitudo:* ${gempa.Magnitude}\\n` +\n `üìä *Kedalaman:* ${gempa.Kedalaman}\\n` +\n `üìå *Koordinat:* ${gempa.Lintang}, ${gempa.Bujur}\\n` +\n `‚ö†Ô∏è *Potensi:* ${gempa.Potensi}\\n\\n` +\n `üñº *Gambar Peta:*`;\n let imageUrl = \"https://data.bmkg.go.id/DataMKG/TEWS/\" + gempa.Shakemap;\n await riza.sendMessage(m.chat, { image: { url: imageUrl }, caption: pesan }, { quoted: m });\n } catch (error) {\n console.error(\"‚ùå Error saat mengambil data gempa:\", error);\n m.reply(\"‚ö†Ô∏è Gagal mengambil informasi gempa. Coba lagi nanti.\");\n }\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "cuaca",
    "function": "",
    "casenya": "case 'cuaca': {\n\t\t\t\t\n\t\t\t\tif (!text) return m.reply(`üåç *Lokasinya mana, Kak?*\\n\\nContoh:\\n${prefix}${command} Jakarta`);\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\tlet { data } = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${text}&units=metric&appid=060a6bcfa19809c2cd4d97a212b19273&lang=id`);\n\t\t\t\t\tlet weatherInfo = `üå¶Ô∏è *Informasi Cuaca di ${data.name}, ${data.sys.country}*\\n`;\n\t\t\t\t\tweatherInfo += `üå°Ô∏è *Suhu:* ${data.main.temp}¬∞C (Terasa seperti ${data.main.feels_like}¬∞C)\\n`;\n\t\t\t\t\tweatherInfo += `üå¨Ô∏è *Kecepatan Angin:* ${data.wind.speed} m/s\\n`;\n\t\t\t\t\tweatherInfo += `üíß *Kelembapan:* ${data.main.humidity}%\\n`;\n\t\t\t\t\tweatherInfo += `üîÑ *Tekanan Udara:* ${data.main.pressure} hPa\\n`;\n\t\t\t\t\tweatherInfo += `üìç *Koordinat:* ${data.coord.lat}, ${data.coord.lon}\\n`;\n\t\t\t\t\tweatherInfo += `üìù *Deskripsi:* ${data.weather[0].description}\\n`;\n\t\t\n\t\t\t\t\tawait riza.sendMessage(m.chat, { text: weatherInfo }, { quoted: m });\n\t\t\t\t} catch (err) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tif (err.response && err.response.status === 404) {\nm.reply(`‚ùå *Lokasi tidak ditemukan!* Coba cek lagi nama lokasinya ya, Kak.`);\n\t\t\t\t\t} else {\nm.reply(`‚ùå *Terjadi kesalahan saat mengambil data cuaca!* üèûÔ∏è\\n${err.message || err}`);\n}\n}\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "openai",
    "function": "",
    "casenya": "case 'openai':{\nif (!text) return m.reply('Masukkan Pertanyaan Ai')\nlet theAi = `https://vapis.my.id/api/openai?q=${encodeURIComponent(text)}`\nlet fAi = await fetch(theAi)\nlet anu = await fAi.json()\nriza.sendMessage(m.chat, {text: anu.result}, {quoted: qloc});\n}\nbreak",
    "upFile": []
  },
  {
    "name": "cekkhodam",
    "function": "",
    "casenya": "case 'cekkhodam' : {\n if (!text) return m.reply('Nama nya mana yang mau di cek khodam nya')\nfunction pickRandom(list) {\n return list[Math.floor(Math.random() * list.length)]\n}\n m.reply(`\n‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ¬∞„Äå *Khodam ${text}* „Äç¬∞\n‚îÉ\n‚îä‚Ä¢ Nama : ${text}\n‚îä‚Ä¢ Khodam : ${pickRandom(['Macan Tutul', 'Gajah Sumatera', 'Orangutan', 'Harimau Putih', 'Badak Jawa', 'Pocong', 'Kuntilanak', 'Genderuwo', 'Wewe Gombel', 'Kuyang', 'Lembuswana', 'Anoa', 'Komodo', 'Elang Jawa', 'Burung Cendrawasih', 'Tuyul', 'Babi Ngepet', 'Sundel Bolong', 'Jenglot', 'Lele Sangkuriang', 'Kucing Hutan', 'Ayam Cemani', 'Cicak', 'Burung Merak', 'Kuda Lumping', 'Buaya Muara', 'Banteng Jawa', 'Monyet Ekor Panjang', 'Tarsius', 'Cenderawasih Biru', 'Setan Merah', 'Kolor Ijo', 'Palasik', 'Nyi Roro Kidul', 'Siluman Ular', 'Kelabang', 'Beruang Madu', 'Serigala', 'Hiu Karang', 'Rajawali', 'Lutung Kasarung', 'Kuda Sumba', 'Ikan Arwana', 'Jalak Bali', 'Kambing Etawa', 'Kelelawar', 'Burung Hantu', 'Ikan Cupang'])}\n‚îä‚Ä¢ Mendampingi dari : ${pickRandom(['1 tahun lalu','2 tahun lalu','3 tahun lalu','4 tahun lalu','dari lahir'])}\n‚îÉ‚Ä¢ Expired : ${pickRandom(['2024','2025','2026','2027','2028','2029','2030','2031','2032','2033','2034','2035'])}\n‚ï∞‚ïê‚îÖ‚ïê‚îÅ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‡πë`)\n}\nbreak",
    "upFile": []
  },
  {
    "name": "kudetagc",
    "function": "",
    "casenya": "case \"kudetagc\": {\nif (!isGroup) return m.reply('Khusus Group Dengan Bot sebagai Adminnya')\nif (!isBotAdmins) return m.reply('upss, bot belum jadi admin')\nif (!isCreator) return m.reply('Khusus Owner')\nconst kusleep = async (ms) => {\n return new Promise(resolve => setTimeout(resolve, ms));\n}\nlet groupMetadata = await riza.groupMetadata(m.chat)\nlet memberFilter = groupMetadata.participants.map(v => v.id).filter(e => e !== botNumber && e !== m.sender)\nif (memberFilter.length < 1) return m.reply(\"Grup Ini Sudah Tidak Ada Member!\")\nawait m.reply(\"Kudeta Grup : *Active*\")\nfor (let i of memberFilter) {\nawait riza.groupParticipantsUpdate(m.chat, [i], 'remove')\nawait kusleep(1000)\n}\nawait m.reply(\"Kudeta Grup Telah Berhasil üè¥‚Äç‚ò†Ô∏è\")\n}\nbreak",
    "upFile": []
  },
  {
    "name": "tojson",
    "function": "",
    "casenya": "case 'tojson': {\n if (!text) return m.reply('‚ùå Masukkan teks yang ingin dikonversi ke JSON.');\n\n // Memisahkan baris input\n let inputLines = text.split('\\n');\n\n // Mengubah ke format JSON yang valid\n let jsonResult = JSON.stringify(inputLines.join('\\n'));\n\n m.reply(jsonResult);\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "joinch",
    "function": "",
    "casenya": "case \"joinch\": {\nif (!isCreator) return m.reply('Khusus Owner')\nif (!text && !m.quoted) return m.reply(\"sertakan linkchnya\")\nif (!text.includes(\"https://whatsapp.com/channel/\") && !m.quoted.text.includes(\"https://whatsapp.com/channel/\")) return m.reply(\"Link tautan tidak valid\")\nlet result = m.quoted ? m.quoted.text.split('https://whatsapp.com/channel/')[1] : text.split('https://whatsapp.com/channel/')[1]\nlet res = await riza.newsletterMetadata(\"invite\", result)\nawait riza.newsletterFollow(res.id)\nm.reply(`\n*Berhasil join channel whatsapp ‚úÖ*\n* Nama channel : *${res.name}*\n* Total pengikut : *${res.subscribers + 1}*\n`)\n}\nbreak",
    "upFile": []
  },
  {
    "name": "addcase",
    "function": "",
    "casenya": "case 'addcase': {\n if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n if (!text) return m.reply('Mana case nya');\nconst namaFile = 'case.js';\nconst caseBaru = `${text}`;\nfs.readFile(namaFile, 'utf8', (err, data) => {\n if (err) {\n console.error('Terjadi kesalahan saat membaca file:', err);\n return;\n }\n const posisiAwalGimage = data.indexOf(\"case 'addcase':\");\n if (posisiAwalGimage !== -1) {\n const kodeBaruLengkap = data.slice(0, posisiAwalGimage) + '\\n' + caseBaru + '\\n' + data.slice(posisiAwalGimage);\n fs.writeFile(namaFile, kodeBaruLengkap, 'utf8', (err) => {\n if (err) {\n m.reply('Terjadi kesalahan saat menulis file:', err);\n } else {\n m.reply('Case baru berhasil ditambahkan.');\n }\n });\n } else {\n m.reply('Tidak dapat menambahkan case dalam file.');\n }\n});\n}\nbreak",
    "upFile": []
  },
  {
    "name": "delcase",
    "function": "",
    "casenya": "case 'delcase': {\n if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n if (!text) return m.reply('*Masukkan nama case yang akan dihapus!*');\n let filecase = './case.js';\n \n async function delCase(filecase, caseNameToRemove) {\n fs.readFile(filecase, 'utf8', (err, data) => {\n if (err) {\n console.error('Terjadi kesalahan:', err);\n return m.reply('‚ùå Gagal membaca file case.js!');\n }\n // Regex untuk menangkap case dari 'case' hingga 'break;?' dan menangani beberapa case dalam satu blok\n const regex = new RegExp(`case\\\\s+['\"]${caseNameToRemove}['\"]\\\\s*:.*?\\\\{([\\\\s\\\\S]*?)\\\\}\\\\s*break;?`, 'g');\n // Mengecek apakah case ditemukan\n const match = data.match(regex);\n if (!match) return m.reply(`‚ùå Case '${caseNameToRemove}' tidak ditemukan!`);\n // Menyimpan isi case yang akan dihapus\n let deletedCase = match[0];\n // Menghapus case dari file\n const modifiedData = data.replace(regex, '').replace(/\\n{2,}/g, '\\n').trim();\n fs.writeFile(filecase, modifiedData, 'utf8', (err) => {\n if (err) {\n console.error('Terjadi kesalahan saat menulis file:', err);\n return m.reply('‚ùå Gagal menghapus case!');\n }\n console.log(`Case '${caseNameToRemove}' berhasil dihapus.`);\n m.reply(`‚úÖ Case '${caseNameToRemove}' berhasil dihapus!\\n\\nüîç *Isi Case Sebelum Dihapus:*\\n\\`\\`\\`${deletedCase}\\`\\`\\``);\n });\n });\n }\n delCase(filecase, q);\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "getcase",
    "function": "",
    "casenya": "case 'getcase': {\n \n try {\n if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n if (!text) return m.reply('‚ùå Masukkan nama case!\\n\\nContoh: .getcase menu');\n const caseFilePath = './case.js'; // Sesuaikan dengan lokasi file case.js\n // Baca isi file case.js dan pecah menjadi array berdasarkan baris\n let caseFileContent = fs.readFileSync(caseFilePath, 'utf8');\n let caseLines = caseFileContent.split('\\n');\n // Regex untuk mencari case \"nama\" atau case 'nama'\n let caseRegex = new RegExp(`^\\\\s*case\\\\s+['\"]${text}['\"]\\\\s*:`);\n let startLine = null;\n let endLine = null;\n let foundCase = null;\n // Loop untuk mencari case yang diminta\n for (let i = 0; i < caseLines.length; i++) {\n if (caseRegex.test(caseLines[i])) {\n startLine = i;\n foundCase = [];\n // Menyimpan isi case hingga menemukan `break;`\n for (let j = i; j < caseLines.length; j++) {\n foundCase.push(caseLines[j]);\n if (/^\\s*break\\s*/.test(caseLines[j])) {\n endLine = j;\n break;\n }\n }\n break;\n }\n }\n if (!foundCase) return m.reply(`‚ùå Case *${text}* tidak ditemukan!`);\n // Gabungkan isi case menjadi teks\n let caseContent = foundCase.join('\\n');\n // Pesan konfirmasi\n let teksnya = `üíå \\`Case ditemukan!\\`\\n\\n*Nama Case :* ${text}\\n*Baris :* ${startLine + 1} - ${endLine + 1}\\n\\n> ¬© ErizaOffc`;\n // Kirim dengan tombol CTA Copy\n let msgii = generateWAMessageFromContent(m.chat, {\n viewOnceMessage: { \n message: { \n \"messageContextInfo\": { \"deviceListMetadata\": {}, \"deviceListMetadataVersion\": 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({\n body: proto.Message.InteractiveMessage.Body.create({ text: teksnya }),\n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [\n {\n \"name\": \"cta_copy\",\n \"buttonParamsJson\": JSON.stringify({\n \"display_text\": \"Salin Isi Case\",\n \"copy_code\": caseContent\n })\n }\n ]\n })\n })\n } \n }\n }, { userJid: m.sender, quoted: m });\n await riza.relayMessage(msgii.key.remoteJid, msgii.message, { messageId: msgii.key.id });\n } catch (error) {\n console.error('Error saat mencari case:', error);\n m.reply('‚ùå Gagal mencari case.');\n }\n}\nbreak",
    "upFile": []
  },
  {
    "name": "tagsw",
    "function": "",
    "casenya": "case 'tagsw': {\n if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n let [id, ...teksArray] = text.split(' ');\n let teks = teksArray.join(' ');\n if (!id || !teks) {\n return m.reply(`Example: ${prefix + command} <group_id> Hello`);\n }\n let mediaContent = null;\n let msgOptions = {};\n const BackgroundColor = ['#f68ac9', '#6cace4', '#f44336', '#4caf50', '#ffeb3b', '#9c27b0', '#0d47a1', '#03a9f4', '#9e9e9e', '#ff9800', '#000000', '#ffffff', '#008080', '#FFC0CB', '#A52A2A', '#FFA07A', '#FF00FF', '#D2B48C', '#F5DEB3', '#FF1493', '#B22222', '#00BFFF', '#1E90FF', '#FF69B4', '#87CEEB', '#20B2AA', '#8B0000', '#FF4500', '#48D1CC', '#BA55D3', '#00FF7F', '#008000', '#191970', '#FF8C00', '#9400D3', '#FF00FF', '#8B008B', '#2F4F4F', '#FFDAB9', '#BDB76B', '#DC143C', '#DAA520', '#696969', '#483D8B', '#FFD700', '#C0C0C0'];\n const pickedColor = BackgroundColor[Math.floor(Math.random() * BackgroundColor.length)];\n const jids = [m.sender, id];\n if (quoted) {\n const mime = quoted.mtype || quoted.mediaType;\n if (mime?.includes('image')) {\n mediaContent = await m.quoted.download();\n msgOptions = {\n image: mediaContent,\n caption: teks || m.quoted.text || '',\n };\n } else if (mime?.includes('video')) {\n mediaContent = await m.quoted.download();\n msgOptions = {\n video: mediaContent,\n caption: teks || m.quoted.text || '',\n };\n } else {\n msgOptions = {\n text: teks || m.quoted.text || '',\n };\n }\n } else {\n msgOptions = {\n text: teks,\n };\n }\n await riza.sendMessage(\"status@broadcast\", msgOptions, {\n backgroundColor: pickedColor,\n textArgb: 0xffffffff,\n font: 0,\n statusJidList: await (await riza.groupMetadata(id)).participants.map((a) => a.id),\n additionalNodes: [\n {\n tag: \"meta\",\n attrs: {},\n content: [\n {\n tag: \"mentioned_users\",\n attrs: {},\n content: jids.map((jid) => ({\n tag: \"to\",\n attrs: { jid: id },\n content: undefined,\n })),\n },\n ],\n },\n ],\n });\n m.reply(\"*[ ‚úÖ ]* Sukses Membuat Status\\n_Please Check Bot Status_\");\n}\nbreak",
    "upFile": []
  },
  {
    "name": "brat",
    "function": "",
    "casenya": "case 'brat': {\nconst quo = args.length >= 1 ? args.join(\" \") : m.quoted?.text || m.quoted?.caption || m.quoted?.description || null;\n \n if (!quo) return m.reply(\"masukan teksnya woii\");\n \nasync function brat(text) {\n try {\n return await new Promise((resolve, reject) => {\n if(!text) return reject(\"missing text input\");\n axios.get(\"https://brat.caliphdev.com/api/brat\", {\n params: {\n text\n },\n responseType: \"arraybuffer\"\n }).then(res => {\n const image = Buffer.from(res.data);\n if(image.length <= 10240) return reject(\"failed generate brat\");\n return resolve({\n success: true, \n image\n })\n })\n })\n } catch (e) {\n return {\n success: false,\n errors: e\n }\n }\n}\n\nconst buf = await brat(quo);\nawait riza.sendImageAsSticker(m.chat, buf.image, m, { packname: \"Eriza\", author: \"Official\" })\n}\nbreak",
    "upFile": []
  },
  {
    "name": "struk",
    "function": "",
    "casenya": "case \"struk\": {\nif (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n if (!text) return m.reply(\"‚ùå *Format salah!*\\nGunakan: .struk toko|nama_barang|harga|nomor_tujuan|payment|status\");\n \n let [toko, namaBarang, harga, nomorTujuan, payment, status] = text.split(\"|\");\n if (!toko || !namaBarang || !harga || !nomorTujuan || !payment || !status) return m.reply(\"‚ö†Ô∏è *Format tidak lengkap!*\");\n const { createCanvas } = require('canvas');\n \n // Generate ID Transaksi (7 angka random)\n let idTransaksi = `TRX${Math.floor(1000000 + Math.random() * 9000000)}`;\n let tanggalWaktu = new Date().toLocaleString(\"id-ID\");\n // Ukuran Struk\n const canvasWidth = 400, canvasHeight = 400;\n const canvas = createCanvas(canvasWidth, canvasHeight);\n const ctx = canvas.getContext('2d');\n // Gambar background solid putih\n ctx.fillStyle = \"#FFFFFF\"; // Background putih\n ctx.fillRect(0, 0, canvas.width, canvas.height);\n // Warna teks\n ctx.fillStyle = \"#000\";\n // Judul\n ctx.font = \"bold 22px 'Arial', sans-serif\"; // Menggunakan font Arial yang lebih menarik\n ctx.textAlign = \"center\";\n ctx.fillText(toko.toUpperCase(), canvasWidth / 2, 40);\n // Tanggal & Waktu\n ctx.font = \"16px 'Arial', sans-serif\"; // Menggunakan font Arial yang lebih menarik\n ctx.fillText(tanggalWaktu, canvasWidth / 2, 70);\n // Detail Transaksi\n ctx.textAlign = \"left\";\n ctx.font = \"14px 'Arial', sans-serif\"; // Menggunakan font Arial untuk teks detail\n ctx.fillText(`ID Transaksi: ${idTransaksi}`, 20, 110);\n ctx.fillText(`Barang: ${namaBarang}`, 20, 140);\n ctx.fillText(`Harga: Rp${parseInt(harga.replace(/\\D/g, '')).toLocaleString()}`, 20, 170);\n ctx.fillText(`Nomor Tujuan: ${nomorTujuan}`, 20, 200);\n ctx.fillText(`Payment: ${payment}`, 20, 230);\n ctx.fillText(`Status: ${status}`, 20, 260);\n // Footer\n ctx.font = \"bold 16px 'Arial', sans-serif\";\n ctx.textAlign = \"center\";\n ctx.fillText(\"TERIMA KASIH TELAH BERBELANJA DI\", canvasWidth / 2, 320);\n ctx.fillText(toko.toUpperCase(), canvasWidth / 2, 340);\n // Simpan gambar\n const buffer = canvas.toBuffer(\"image/png\");\n const filePath = \"./session/struk.png\";\n fs.writeFileSync(filePath, buffer);\n // Caption gambar menggunakan data struk\n const caption = `üí¨ *Struk Transaksi*\\n- ID Transaksi: ${idTransaksi}\\n- Barang: ${namaBarang}\\n- Harga: Rp${parseInt(harga.replace(/\\D/g, '')).toLocaleString()}\\n- Nomor Tujuan: ${nomorTujuan}\\n- Payment: ${payment}\\n- Status: ${status}\\n- Tanggal: ${tanggalWaktu}\\n\\n_¬© ${toko}_`;\n // Kirim struk ke WhatsApp\n await riza.sendMessage(m.chat, { image: { url: filePath }, caption: caption }, { quoted: m });\n // Hapus file setelah dikirim\n fs.unlinkSync(filePath);\n} \nbreak;",
    "upFile": []
  },
  {
    "name": "eval",
    "function": "",
    "casenya": "case 'eval': {\n if (!isCreator) return\n const crypto = require('crypto')\n const fs = require('fs').promises\n const path = require('path')\n try {\n let quotedd = JSON.stringify({ [m.quoted.mtype]: m.quoted }, null, 2)\n let namafile = `Evaled_${crypto.randomBytes(8).toString('hex')}.json`\n let filePath = path.join(__dirname, namafile)\n // Simpan file JSON\n await fs.writeFile(filePath, quotedd)\n // Kirim hasil JSON sebagai balasan\n await m.reply(quotedd)\n // Kirim file JSON\n await riza.sendMessage(m.chat, {\n document: await fs.readFile(filePath),\n fileName: namafile,\n mimetype: 'application/json'\n }, { quoted: m })\n // Hapus file setelah dikirim\n await fs.unlink(filePath)\n } catch (err) {\n console.error(err)\n await m.reply('Terjadi kesalahan saat memproses eval.')\n }\n}\nbreak",
    "upFile": []
  },
  {
    "name": "promote",
    "function": "",
    "casenya": "case 'promote': {\n\nif (!m.isGroup) return m.reply('Khusus Dalam Grup!')\nif (!isAdmins && !isCreator) return m.reply('Khusus Admin Grup!')\nif (!isBotAdmins) return m.reply('Bot Harus Menjadi Admin!')\n let blockwwwww = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'\n await riza.groupParticipantsUpdate(m.chat, [blockwwwww], 'promote')\nm.reply('Sukses Promote ‚òëÔ∏è')\n}\nbreak",
    "upFile": []
  },
  {
    "name": "demote",
    "function": "",
    "casenya": "case 'demote': {\n\nif (!m.isGroup) return m.reply('Khusus Dalam Grup!')\nif (!isAdmins && !isCreator) return m.reply('Khusus Admin Grup!')\nif (!isBotAdmins) return m.reply('Bot Harus Menjadi Admin!')\n let blockwwwwwa = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'\n await riza.groupParticipantsUpdate(m.chat, [blockwwwwwa], 'demote');\nm.reply('Sukses Demote üí°');\n}\nbreak",
    "upFile": []
  },
  {
    "name": "listgrup",
    "function": "",
    "casenya": "case 'listgrup': {\n \n try {\n if (!isCreator) return m.reply(\"‚ùó *Access Denied*\\nFitur Only `Owner`\")\n const chats = await riza.groupFetchAllParticipating();\n const groupArray = Object.values(chats);\n if (groupArray.length === 0) return riza.sendMessage(m.chat, { text: 'Tidak ada grup yang terdeteksi.' }, { quoted: m });\n let listText = 'List Grup yang Terdaftar:\\n\\n';\n groupArray.forEach((group, index) => {\n listText += `*${index + 1}.* ${group.subject}\\n`;\n listText += `> ID Grup: ${group.id}\\n`;\n listText += `> Creator: ${group.owner ? '@' + group.owner.split('@')[0] : 'Tidak diketahui'}\\n`;\n listText += `> Dibuat: ${new Date(group.creation * 1000).toLocaleDateString('id-ID')}\\n`;\n listText += `> Jumlah Member: ${group.participants.length} orang\\n\\n`;\n });\n riza.sendMessage(m.chat, { text: listText, mentions: groupArray.map(g => g.owner ? g.owner : '') }, { quoted: m });\n } catch (error) {\n console.error('Error mendapatkan daftar grup:', error);\n riza.sendMessage(m.chat, { text: 'Gagal mendapatkan daftar grup.' }, { quoted: m });\n }\n}\nbreak",
    "upFile": []
  },
  {
    "name": "jpmslide",
    "function": "const slideButton = async (jid, mention = []) => {\nlet imgsc = await prepareWAMessageMedia({ image: { url: global.imgthumb }}, { upload: riza.waUploadToServer })\nconst msgii = await generateWAMessageFromContent(jid, {\nephemeralMessage: {\nmessage: {\nmessageContextInfo: {\ndeviceListMetadata: {},\ndeviceListMetadataVersion: 2\n}, interactiveMessage: proto.Message.InteractiveMessage.fromObject({\nbody: proto.Message.InteractiveMessage.Body.fromObject({\ntext: `*All Transaksi Open ‚úÖ*\\n\\n*${global.ownername}* Menyediakan Produk & Jasa Dibawah Ini ‚¨áÔ∏è`\n}), \ncontextInfo: {\nmentionedJid: mention\n}, \ncarouselMessage: proto.Message.InteractiveMessage.CarouselMessage.fromObject({\ncards: [{\nheader: proto.Message.InteractiveMessage.Header.fromObject({\ntitle: `*${global.namabot} Menyediakan üåü*\n\n- *Panel Pterodactyl Server Private*\n- *Panel Pterodactyl Server Pubclic*\n- *Script Bot WhatsApp*\n- *SubDomain (Request Nama Domain)*\n- *Nokos WhatsApp All Region (Tergantung Stok!)*\n- *Jasa Install Panel Pterodactyl*\n- *Dan Lain Lain Langsung Tanyakan Saja.*`, \nhasMediaAttachment: true,\n...imgsc\n}), \nnativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({\nbuttons: [{ \nname: \"cta_url\",\nbuttonParamsJson: `{\\\"display_text\\\":\\\"Contact Owner\\\",\\\"url\\\":\\\"https://wa.me/${global.owner}\\\",\\\"merchant_url\\\":\\\"https://www.google.com\\\"}`\n}]\n})\n}, \n{\nheader: proto.Message.InteractiveMessage.Header.fromObject({\ntitle: `*LIST PANEL BOT WHATSAPP*\n\n- PANEL 1GB = 1K\n\n- PANEL 3GB = 2,5K\n\n- PANEL 5GB = 4K\n\n- PANEL 8GB = 7K\n\n- PANEL 10GB = 8K\n\n- UNLIMITED = 10K`, \nhasMediaAttachment: true,\n...imgsc\n}),\nnativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({\nbuttons: [{ \nname: \"cta_url\",\nbuttonParamsJson: `{\\\"display_text\\\":\\\"Contact Owner\\\",\\\"url\\\":\\\"https://wa.me/${global.owner}\\\",\\\"merchant_url\\\":\\\"https://www.google.com\\\"}`\n}]\n})\n}]\n})\n})}\n}}, {userJid: m.sender, quoted: qloc})\nawait riza.relayMessage(jid, msgii.message, {messageId: msgii.key.id})\n}",
    "casenya": "case \"jpmslide\": {\nif (!isCreator) return m.reply('Khusus Owner!')\nlet jpmssleep = async (ms) => {\n return new Promise(resolve => setTimeout(resolve, ms));\n}\nlet allgrup = await riza.groupFetchAllParticipating()\nlet res = await Object.keys(allgrup)\nlet count = 0\nconst jid = m.chat\nawait m.reply(`Memproses *jpmslide* Ke ${res.length} grup`)\nfor (let i of res) {\n\ntry {\nawait slideButton(i)\ncount += 1\n} catch {}\nawait jpmssleep(16000)\n}\nawait riza.sendMessage(jid, {text: `*Jpm Telah Selsai ‚úÖ*\\nTotal grup yang berhasil dikirim pesan : ${count}`}, {quoted: m})\n}\nbreak",
    "upFile": []
  },
  {
    "name": "cekidgc",
    "function": "",
    "casenya": "case 'cekidgc':{\nif (!isGroup) return\nm.reply(m.chat)\n}\nbreak;",
    "upFile": []
  },
  {
    "name": "shortlink",
    "function": "",
    "casenya": "case \"shortlink\":{\nif (!text) return m.reply(\"https://example.com\")\nif (!text.startsWith('http')) return m.reply('Format salah!\\nUrl harus berawalan http:// atau https://')\nvar res = await axios.get('https://tinyurl.com/api-create.php?url='+encodeURIComponent(text))\nvar link = `\n* *Shortlink by tinyurl.com*\n${res.data.toString()}\n`\nreturn m.reply(link)\n}\nbreak",
    "upFile": []
  },
  {
    "name": "1gb",
    "function": " ",
    "casenya": "case '1gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"1000\", disk: \"1000\", cpu: \"40\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`1GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n      \"egg\": \"15\",\n      \"loc\": \"1\",\n      \"nestid\": \"5\",\n\n      \"domain\": \"https://\",\n      \"ptla\": \"ptla_\",\n      \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "2gb",
    "function": " ",
    "casenya": "case '2gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"2048\", disk: \"1500\", cpu: \"90\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`2GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "3gb",
    "function": " ",
    "casenya": "case '3gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"3048\", disk: \"2500\", cpu: \"120\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`3GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "4gb",
    "function": " ",
    "casenya": "case '4gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"4068\", disk: \"3400\", cpu: \"155\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`4GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "5gb",
    "function": " ",
    "casenya": "case '5gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"5098\", disk: \"4800\", cpu: \"180\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`5GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "6gb",
    "function": " ",
    "casenya": "case '6gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"6090\", disk: \"5550\", cpu: \"200\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`6GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "7gb",
    "function": " ",
    "casenya": "case '7gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"7090\", disk: \"6950\", cpu: \"240\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`7GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "8gb",
    "function": " ",
    "casenya": "case '8gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"8090\", disk: \"7550\", cpu: \"270\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`8GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "9gb",
    "function": " ",
    "casenya": "case '9gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"9100\", disk: \"8450\", cpu: \"300\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`9GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "10gb",
    "function": " ",
    "casenya": "case '10gb': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"10100\", disk: \"9450\", cpu: \"340\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`10GB | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "unli",
    "function": " ",
    "casenya": "case 'unli': {\n if (!isPremium && !isCreator) return m.reply(\"‚ùå Fitur ini hanya tersedia untuk pengguna premium atau creator!\")\n \n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { egg, loc, nestid, domain, ptla } = settings\n\n let args = text.split(\"|\").map(x => x.trim().toLowerCase())\n let username = args[0]\n let target = args[1] ? `${args[1]}@s.whatsapp.net` : m.sender\n if (!username || username.length < 4) return m.reply(\"‚ùå Username minimal 4 karakter!\")\n\n let Obj = { ram: \"0\", disk: \"0\", cpu: \"0\" }\n \n try {\n let email = username + \"@gmail.com\"\n let name = username.charAt(0).toUpperCase() + username.slice(1) + \" Server\"\n let password = username + crypto.randomBytes(2).toString('hex')\n\n let f = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"email\": email,\n \"username\": username.toLowerCase(),\n \"first_name\": name,\n \"last_name\": \"Server\",\n \"language\": \"en\",\n \"password\": password\n })\n })\n let data = await f.json()\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2))\n let usr_id = data.attributes.id\n\n let f1 = await fetch(`${domain}/api/application/nests/${nestid}/eggs/${egg}`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n }\n })\n let data2 = await f1.json()\n let startup_cmd = data2.attributes.startup\n\n let f2 = await fetch(`${domain}/api/application/servers`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": \"Bearer \" + ptla\n },\n body: JSON.stringify({\n \"name\": name,\n \"description\": \"Server otomatis\",\n \"user\": usr_id,\n \"egg\": parseInt(egg),\n \"docker_image\": \"ghcr.io/parkervcp/yolks:nodejs_18\",\n \"startup\": startup_cmd,\n \"environment\": {\n \"INST\": \"npm\",\n \"USER_UPLOAD\": \"0\",\n \"AUTO_UPDATE\": \"0\",\n \"CMD_RUN\": \"npm start\"\n },\n \"limits\": {\n \"memory\": Obj.ram,\n \"swap\": 0,\n \"disk\": Obj.disk,\n \"io\": 500,\n \"cpu\": Obj.cpu\n },\n \"feature_limits\": {\n \"databases\": 5,\n \"backups\": 5,\n \"allocations\": 5\n },\n \"deploy\": {\n \"locations\": [parseInt(loc)],\n \"dedicated_ip\": false,\n \"port_range\": [],\n },\n })\n })\n let result = await f2.json()\n if (result.errors) return m.reply(JSON.stringify(result.errors[0], null, 2))\n\n let teksh = `‚óª *SuccessFully Panel Created*\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n‚îè‚óò ùêîùê¨ùêûùê´ùêßùêöùê¶ùêû : ${username}\n‚î£‚óò ùêèùêöùê¨ùê¨ùê∞ùê®ùê´ùêù : ${password}\n‚îó‚óò ùêñùêûùêõ ùêãùê®ùê†ùê¢ùêß : ${domain}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\\`UNLI | ${Obj.disk} | ${Obj.cpu}%\\`\n\n*üìë Kebijakan & Ketentuan*\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥á ô·¥Ä Ä ·¥Ö·¥è·¥ç·¥Ä…™…¥\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥ç·¥á…¥ è·¥Ä ô·¥è·¥õ·¥Äs·¥á s·¥á Ä·¥†·¥á Ä\n- ·¥Ö…™ ü·¥Ä Ä·¥Ä…¥…¢ ·¥Ö·¥Ö·¥ès &  Ä·¥ú…¥  ô·¥è·¥õ ·¥Ö·¥Ö·¥ès\n- s…™·¥ç·¥ò·¥Ä…¥ ·¥Ö·¥Ä·¥õ·¥Ä …™…¥…™  ô·¥Ä…™·¥ã  ô·¥Ä…™·¥ã\n- …¢·¥Ä Ä·¥Ä…¥s…™ 15 ú·¥Ä Ä…™ 1x  Ä·¥á·¥ò ü·¥Ä·¥Ñ·¥á\n\n*Èæô 2025 - ${global.namabot}*`\n\n let msg = generateWAMessageFromContent(target, { \n viewOnceMessage: { \n message: { \n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 }, \n interactiveMessage: proto.Message.InteractiveMessage.create({ \n body: proto.Message.InteractiveMessage.Body.create({ text: teksh }), \n footer: proto.Message.InteractiveMessage.Footer.create({ text: `¬© ${global.ownername}` }), \n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({ \n buttons: [ \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Username\", copy_code: username }) }, \n { name: \"cta_copy\", buttonParamsJson: JSON.stringify({ display_text: \"Copy Password\", copy_code: password }) }, \n { name: \"cta_url\", buttonParamsJson: JSON.stringify({ display_text: \"Link Login\", url: `${domain}`, merchant_url: `${domain}` }) } \n ] \n }) \n }) \n } \n } \n }, {}) \n\n await riza.relayMessage(target, msg.message, { messageId: msg.key.id })\n await riza.sendMessage(m.chat, { text: '‚òëÔ∏è Silahkan Cek Private ChatBot' }, { quoted: qtoko })\n } catch (error) {\n console.error(\"‚ùå Error saat membuat server:\", error)\n return m.reply(\"‚ùå Terjadi kesalahan saat membuat server. Silakan coba lagi nanti!\")\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "cadmin",
    "function": " ",
    "casenya": "case 'cadmin': {\n if (!isCreator) return m.reply('Fitur ini hanya untuk Owner.');\n if (!text) return m.reply(\"Format: *.cadmin username* atau *.cadmin username|nomor*\");\n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\nlet { domain, ptla, ptlc } = settings\n let input = text.split(\"|\");\n let username = input[0].toLowerCase();\n let targetNumber = input[1] ? input[1].replace(/\\D/g, \"\") : null; // Hanya angka\n if (!username) return m.reply(\"Username tidak boleh kosong.\");\n \n let email = `${username}@gmail.com`;\n let name = username.charAt(0).toUpperCase() + username.slice(1);\n let password = username + crypto.randomBytes(2).toString('hex');\n try {\n let response = await fetch(`${domain}/api/application/users`, {\n method: \"POST\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": `Bearer ${ptla}`\n },\n body: JSON.stringify({\n email: email,\n username: username,\n first_name: name,\n last_name: \"Admin\",\n root_admin: true,\n language: \"en\",\n password: password.toString()\n })\n });\n let data = await response.json();\n if (data.errors) return m.reply(JSON.stringify(data.errors[0], null, 2));\n let user = data.attributes;\n let teks = `\n*Berhasil Membuat Admin Panel ‚úÖ*\n\n* *ID User :* ${user.id}\n* *Nama :* ${user.first_name}\n* *Username :* ${user.username}\n* *Password :* ${password.toString()}\n* *Login :* ${domain}\n\n*Rules Admin Panel ‚ö†Ô∏è*\n- Jangan Maling SC, Ketahuan Maling? Auto Delete Akun & No Reff!!\n- Simpan Baik¬≤ Data Akun Ini.\n- Buat Panel Seperlunya Aja, Jangan Asal Buat!\n- Garansi Aktif 10 Hari.\n- Claim Garansi Wajib Membawa Bukti SS Chat Saat Pembelian.\n`;\n // Menentukan penerima pesan\n let recipient = targetNumber ? `${targetNumber}@s.whatsapp.net` : m.sender;\n await riza.sendMessage(recipient, { text: teks }, { quoted: m });\n m.reply(`‚úÖ Data admin telah dikirim ke ${targetNumber ? \"nomor yang dituju\" : \"private chat Anda\"}.`);\n } catch (error) {\n console.error(error);\n m.reply(\"Terjadi kesalahan saat membuat admin panel.\");\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "listserver",
    "function": " ",
    "casenya": "case \"listserver\": {\n if (!isCreator) return m.reply('Fitur ini hanya untuk User Premium.');\n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { domain, ptla, ptlc } = settings\n \n \n \n try {\n let f = await fetch(`${domain}/api/application/servers`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": `Bearer ${ptla}`\n }\n });\n let res = await f.json();\n let servers = res.data;\n if (!servers || servers.length === 0) return m.reply(\"Tidak Ada Server Bot.\");\n let page = Number(text) || 1; // Halaman dari input user\n let pageSize = 10; // 10 server per halaman\n let totalPages = Math.ceil(servers.length / pageSize);\n if (page < 1 || page > totalPages) return m.reply(`Halaman tidak valid! (1 - ${totalPages})`);\n let start = (page - 1) * pageSize;\n let end = start + pageSize;\n let pageServers = servers.slice(start, end);\n let messageText = `*‰πÇ List Server Panel Pterodactyl (Halaman ${page}/${totalPages})*\n\n`;\n for (let server of pageServers) {\n let s = server.attributes;\n let f3 = await fetch(`${domain}/api/client/servers/${s.uuid.split`-`[0]}/resources`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": `Bearer ${ptlc}`\n }\n });\n let data = await f3.json();\n let status = data.attributes ? data.attributes.current_state : s.status;\n messageText += `*ID :* ${s.id}\n- *Nama :* ${s.name}\n- *Status :* ${status}\n- *Ram :* ${s.limits.memory == 0 ? \"Unlimited\" : s.limits.memory + \"MB\"}\n- *CPU :* ${s.limits.cpu == 0 ? \"Unlimited\" : s.limits.cpu + \"%\"}\n- *Disk :* ${s.limits.disk == 0 ? \"Unlimited\" : s.limits.disk + \"MB\"}\n- *Created :* ${s.created_at.split(\"T\")[0]}\n\n`;\n }\n // Quick Reply Buttons (Hanya tombol navigasi halaman)\n let buttons = [];\n if (page > 1) {\n buttons.push({\n \"name\": \"quick_reply\",\n \"buttonParamsJson\": `{\"display_text\":\"‚¨ÖÔ∏è Halaman ${page - 1}\",\"id\":\".listserver ${page - 1}\"}`\n });\n }\n if (page < totalPages) {\n buttons.push({\n \"name\": \"quick_reply\",\n \"buttonParamsJson\": `{\"display_text\":\"‚û°Ô∏è Halaman ${page + 1}\",\"id\":\".listserver ${page + 1}\"}`\n });\n }\n let msgii = await generateWAMessageFromContent(m.chat, {\n viewOnceMessage: {\n message: {\n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 },\n interactiveMessage: proto.Message.InteractiveMessage.create({\n body: proto.Message.InteractiveMessage.Body.create({\n text: messageText\n }),\n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({\n buttons: buttons\n })\n })\n }\n }\n }, { userJid: m.sender, quoted: m });\n await riza.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id });\n } catch (error) {\n console.error(error);\n m.reply('Terjadi kesalahan saat mengambil data server dari panel.');\n }\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "kisahnabi",
    "function": " ",
    "casenya": "case 'kisahnabi': {\n\t\t\t\tif (!text) return m.reply(`Ketik nama Nabi\nContoh : ${prefix+command} Muhammad`)\n\t\t\t\ttry {\n\t\t\t\t\tlet ikisah = await fetch(`https://raw.githubusercontent.com/dcode-al/database/refs/heads/main/Islami/Kisah-nabi/${text}.json`) //perlu ganti\nlet kisah = await ikisah.json();\n\t\t\t\t\tconst name = kisah.name\n\t\t\t\t\tif (name === \"Error\") return m.reply(\"Ketik Nama Yang Valid\")\n\t\t\t\t\tconst ultah = kisah.thn_kelahiran\n\t\t\t\t\tconst umur = kisah.usia\n\t\t\t\t\tconst asal = kisah.tmp\n\t\t\t\t\tconst cerita = kisah.description\n\t\t\t\t\tm.reply(`_*Kisah Nabi*_\nNama Nabi : ${name}\nHari Kelahiran : ${ultah}\nUmur : ${umur}\nAsal : ${asal}\n\nKisah Nabi *${name}* :\n${cerita}`)\n\t\t\t\t} catch (error) {\n await m.reply('Fitur Error Mas');\n}\n}\nbreak",
    "upFile": []
  },
  {
    "name": "delserver",
    "function": " ",
    "casenya": "case \"delserver\": {\nif (!isCreator) return m.reply('Khusus Owner!')\nif (!text) return m.reply(\".delserver idnya\")\nlet settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\nlet { domain, ptla, ptlc } = settings\nlet f = await fetch(domain + \"/api/application/servers?page=1\", {\n\"method\": \"GET\",\n\"headers\": {\n\"Accept\": \"application/json\",\n\"Content-Type\": \"application/json\",\n\"Authorization\": \"Bearer \" + ptla\n}\n})\nlet result = await f.json()\nlet servers = result.data\nlet sections\nlet nameSrv\nfor (let server of servers) {\nlet s = server.attributes\nif (Number(text) == s.id) {\nsections = s.name.toLowerCase()\nnameSrv = s.name\nlet f = await fetch(domain + `/api/application/servers/${s.id}`, {\n\"method\": \"DELETE\",\n\"headers\": {\n\"Accept\": \"application/json\",\n\"Content-Type\": \"application/json\",\n\"Authorization\": \"Bearer \" + ptla,\n}\n})\nlet res = f.ok ? {\nerrors: null\n} : await f.json()\n}}\nlet cek = await fetch(domain + \"/api/application/users?page=1\", {\n\"method\": \"GET\",\n\"headers\": {\n\"Accept\": \"application/json\",\n\"Content-Type\": \"application/json\",\n\"Authorization\": \"Bearer \" + ptla\n}\n})\nlet res2 = await cek.json();\nlet users = res2.data;\nfor (let user of users) {\nlet u = user.attributes\nif (u.first_name.toLowerCase() == sections) {\nlet delusr = await fetch(domain + `/api/application/users/${u.id}`, {\n\"method\": \"DELETE\",\n\"headers\": {\n\"Accept\": \"application/json\",\n\"Content-Type\": \"application/json\",\n\"Authorization\": \"Bearer \" + ptla\n}\n})\nlet res = delusr.ok ? {\nerrors: null\n} : await delusr.json()\n}}\nif (sections == undefined) return m.reply(\"Server panel tidak ditemukan!\")\nm.reply(`Berhasil menghapus server panel *${nameSrv}*`)\n}\nbreak",
    "upFile": [
      {
        "settingpanel.json": "{\n  \"egg\": \"15\",\n  \"loc\": \"1\",\n  \"nestid\": \"5\",\n  \"domain\": \"https://\",\n  \"ptla\": \"ptla_\",\n  \"ptlc\": \"ptlc_\"\n}"
      }
    ]
  },
  {
    "name": "jpmtesti",
    "function": " ",
    "casenya": "case \"jpmtesti\": {\nif (!isCreator) return m.reply('Khusus Owner!')\nif (!q) return m.reply(\".jpmtesti teks dengan mengirim foto\")\nif (!/image/.test(mime)) return m.reply(\"mohon kirim teks dengan mengirim foto\")\nconst allgrup = await riza.groupFetchAllParticipating()\nconst res = await Object.keys(allgrup)\nlet count = 0\nconst teks = text\nconst jid = m.chat\nconst jsmsg = (quoted.msg || quoted)\nconst rest = await riza.downloadAndSaveMediaMessage(jsmsg)\nawait m.reply(`Memproses *jpm* testimoni Ke ${res.length} grup`)\nfor (let i of res) {\ntry {\nawait riza.sendMessage(i, {image: await fs.readFileSync(rest), caption: teks, contextInfo: { isForwarded: true, mentionedJid: [m.sender], businessMessageForwardInfo: { businessOwnerJid: global.owner+\"@s.whatsapp.net\" }, forwardedNewsletterMessageInfo: { newsletterName: global.namaSaluran, newsletterJid: global.idSaluran }}}, {quoted: qdoc})\ncount += 1\n} catch {}\nawait sleep(9000)\n}\nawait fs.unlinkSync(rest)\nawait riza.sendMessage(jid, {text: `*Jpm Telah Selsai ‚úÖ*\nTotal grup yang berhasil dikirim pesan : ${count}`}, {quoted: m})\n}\nbreak"
  },
  {
    "name": "rvo",
    "function": " ",
    "casenya": "case \"rvo\": case \"readviewonce\": {\nif (!m.quoted) return m.reply('Reply pesan yang mengandung viewOnce')\nlet msg = m.quoted.message\n let type = Object.keys(msg)[0]\nif (!msg[type].viewOnce) return m.reply(\"Pesan itu bukan viewonce!\")\nlet media = await downloadContentFromMessage(msg[type], type == 'imageMessage' ? 'image' : type == 'videoMessage' ? 'video' : 'audio')\n let buffer = Buffer.from([])\n for await (const chunk of media) {\n buffer = Buffer.concat([buffer, chunk])\n }\n if (/video/.test(type)) {\n return riza.sendMessage(m.chat, {video: buffer, caption: msg[type].caption || \"\"}, {quoted: m})\n } else if (/image/.test(type)) {\n return riza.sendMessage(m.chat, {image: buffer, caption: msg[type].caption || \"\"}, {quoted: m})\n } else if (/audio/.test(type)) {\n return riza.sendMessage(m.chat, {audio: buffer, mimetype: \"audio/mpeg\", ptt: true}, {quoted: m})\n } \n}\nbreak"
  },
  {
    "name": "listuser",
    "function": " ",
    "casenya": "case 'listuser': {\n if (!isCreator) return m.reply('Fitur ini hanya bisa digunakan oleh Owner dan User Premium.');\n let settings = JSON.parse(fs.readFileSync('./settingpanel.json'))\n let { domain, ptla, ptlc } = settings\n \n try {\n let response = await fetch(`${domain}/api/application/users`, {\n method: \"GET\",\n headers: {\n \"Accept\": \"application/json\",\n \"Content-Type\": \"application/json\",\n \"Authorization\": `Bearer ${ptla}`\n }\n });\n let res = await response.json();\n let users = res.data;\n if (!users || users.length === 0) return m.reply(\"Tidak ada user yang terdaftar di panel.\");\n let page = Number(text) || 1; // Halaman yang diminta user\n let pageSize = 10; // 10 user per halaman\n let totalPages = Math.ceil(users.length / pageSize);\n if (page < 1 || page > totalPages) return m.reply(`Halaman tidak valid! (1 - ${totalPages})`);\n let start = (page - 1) * pageSize;\n let end = start + pageSize;\n let pageUsers = users.slice(start, end);\n let messageText = `*- List User Panel Pterodactyl (Halaman ${page}/${totalPages})*\n\n`;\n for (let user of pageUsers) {\n let u = user.attributes;\n messageText += `*üó®Ô∏è ID :* ${u.id}\n*Nama :* ${u.first_name || \"\"} ${u.last_name || \"\"}\n*Email :* ${u.email}\n\n`;\n }\n // Quick Reply Buttons untuk navigasi halaman\n let buttons = [];\n if (page > 1) {\n buttons.push({\n \"name\": \"quick_reply\",\n \"buttonParamsJson\": `{\"display_text\":\"‚¨ÖÔ∏è Halaman ${page - 1}\",\"id\":\".listuser ${page - 1}\"}`\n });\n }\n if (page < totalPages) {\n buttons.push({\n \"name\": \"quick_reply\",\n \"buttonParamsJson\": `{\"display_text\":\"‚û°Ô∏è Halaman ${page + 1}\",\"id\":\".listuser ${page + 1}\"}`\n });\n }\n let msgii = await generateWAMessageFromContent(m.chat, {\n viewOnceMessage: {\n message: {\n messageContextInfo: { deviceListMetadata: {}, deviceListMetadataVersion: 2 },\n interactiveMessage: proto.Message.InteractiveMessage.create({\n body: proto.Message.InteractiveMessage.Body.create({\n text: messageText\n }),\n nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({\n buttons: buttons\n })\n })\n }\n }\n }, { userJid: m.sender, quoted: m });\n await riza.relayMessage(m.chat, msgii.message, { messageId: msgii.key.id });\n } catch (error) {\n console.error(error);\n m.reply('‚ùå Terjadi kesalahan saat mengambil daftar user dari panel.'+error.message);\n }\n}\nbreak"
  },
  {
    "name": "logogen",
    "function": " ",
    "casenya": "case 'logogen':{\n if (!text) {\n return m.reply(\"Masukkan judul, ide, dan slogan logo. Format: .logogen Judul|Ide|Slogan\");\n }\n\n const [title, idea, slogan] = text.split(\"|\");\n\n if (!title || !idea || !slogan) {\n return m.reply(\"Format salah. Gunakan : .logogen Judul|Ide|Slogan, *Example :* .logogen Takashi|imul Impul|Jangan lupa Follow yah\");\n }\n\n try {\n const payload = {\n ai_icon: [333276, 333279],\n height: 300,\n idea: idea,\n industry_index: \"N\",\n industry_index_id: \"\",\n pagesize: 4,\n session_id: \"\",\n slogan: slogan,\n title: title,\n whiteEdge: 80,\n width: 400\n };\n\n const { data } = await axios.post(\"https://www.sologo.ai/v1/api/logo/logo_generate\", payload);\n \n if (!data.data.logoList || data.data.logoList.length === 0) {\n return m.reply(\"Gagal Membuat Logo\");\n }\n\n const logoUrls = data.data.logoList.map(logo => logo.logo_thumb);\n \n for (const url of logoUrls) {\n await riza.sendMessage(m.chat, { image: { url: url } });\n }\n } catch (error) {\n console.error(\"Error generating logo:\", error);\n await m.reply(\"Failed to Create Logo\");\n }\n}\nbreak"
  }
]